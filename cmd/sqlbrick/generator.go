// Copyright (c) 2018-present Anbillon Team (anbillonteam@gmail.com).
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"anbillon.com/x/sqlbrick/cmd/sqlbrick/parser"
	"github.com/gobuffalo/packr"
	"github.com/iancoleman/strcase"
	"golang.org/x/tools/imports"
)

const (
	sqlbrickTemplate = "sqlbrick.tpl"
	brickTemplate    = "brick.tpl"
	ddlTemplate      = "ddl.tpl"
	insertTemplate   = "insert.tpl"
	deleteTemplate   = "delete.tpl"
	updateTemplate   = "update.tpl"
	selectTemplate   = "select.tpl"
)

var templates = map[parser.QueryType]string{
	parser.QueryTypeCreate: ddlTemplate,
	parser.QueryTypeInsert: insertTemplate,
	parser.QueryTypeDelete: deleteTemplate,
	parser.QueryTypeUpdate: updateTemplate,
	parser.QueryTypeSelect: selectTemplate,
}

// Type definition for sqlbrick generator.
type Generator struct {
	buf         bytes.Buffer
	box         packr.Box
	outputDir   string
	packageName string
}

// Type definition for sql functions used to generate sql func.
type SqlFunc struct {
	BrickName    string
	FuncName     string
	Segments     []string
	Conditions   []parser.Condition
	RemoveComma  bool
	IndexOfWhere int
	Mapper       parser.MapperType
	IsTx         bool
	ArgName      string
	Args         []string
	TotalArgs    int
	Comment      string
}

// NewGenerator create a new Generator with output dir and package name.
func NewGenerator(outputDir string, packageName string) *Generator {
	g := &Generator{
		box:         packr.NewBox("./templates"),
		outputDir:   outputDir,
		packageName: packageName,
	}

	return g
}

// header add common headers in output files.
func (g *Generator) header(source string) {
	g.Printf("// Copyright (c) 2018-present Anbillon Team (anbillonteam@gmail.com).")
	g.NewLine()
	g.Printf("// Code generated by sqlbrick. DO NOT EDIT IT.")
	g.NewLine()
	g.NewLine()
	if len(source) != 0 {
		g.Printf(fmt.Sprintf("// This file is generated from: %v", source))
		g.NewLine()
		g.NewLine()
	}
	g.Printf("package " + g.packageName)
	g.NewLine()
}

// Printf will add one line into the generator buffer.
func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// NewLine will add a new line to the generator buffer.
func (g *Generator) NewLine() {
	g.Printf("\n")
}

// applyTemplate will apply data into template
func (g *Generator) applyTemplate(tplName string, data interface{}) error {
	tplFuncMap := make(template.FuncMap)
	cache := make(map[string]interface{})
	tplFuncMap["ToSnake"] = strcase.ToSnake
	tplFuncMap["Add"] = func(a, b int) int {
		return a + b
	}
	tplFuncMap["CacheSet"] = func(key string, value interface{}) string {
		cache[key] = value
		return ""
	}
	tplFuncMap["CacheGet"] = func(key string) interface{} {
		return cache[key]
	}
	tpl, err := template.New("").Funcs(tplFuncMap).Parse(g.box.String(tplName))
	if err != nil {
		return err
	}
	return tpl.Execute(&g.buf, data)
}

// GenerateSqlBrick will add sql brick definition into the generator buffer.
func (g *Generator) GenerateSqlBrick(bricks []string, txMap map[string]bool) {
	if err := g.applyTemplate(sqlbrickTemplate, struct {
		Bricks []string
		TxMap  map[string]bool
	}{
		Bricks: bricks,
		TxMap:  txMap,
	}); err != nil {
		log.Printf("error: %v", err)
	}
}

// CheckTx check if given statements has transaction.
func (g *Generator) CheckTx(statements []parser.Statement) bool {
	var hasTxStatement bool
	for _, v := range statements {
		if v.Definition.IsTx {
			hasTxStatement = true
			break
		}
	}
	return hasTxStatement
}

// GenerateBrick will add brick definition into the generator buffer.
func (g *Generator) GenerateBrick(sourceFilename string, brick string,
	syntaxes []parser.Syntax, statements []parser.Statement) {
	hasTxStatement := g.CheckTx(statements)

	if err := g.applyTemplate(brickTemplate, struct {
		SourceFilename string
		BrickName      string
		HasTx          bool
		Syntaxes       []parser.Syntax
	}{
		SourceFilename: sourceFilename,
		BrickName:      brick,
		HasTx:          hasTxStatement,
		Syntaxes:       syntaxes,
	}); err != nil {
		log.Printf("error: %v", err)
	}
}

// Generate will add func into the generator buffer.
func (g *Generator) Generate(brickName string, statement parser.Statement) {
	dynamicQuery := statement.Query
	definition := statement.Definition
	queryType := dynamicQuery.QueryType
	tpl, found := templates[queryType]
	if !found {
		log.Printf("no template found for given query:\n %v", dynamicQuery.Segments)
		return
	}
	var argName = "args"
	argsLen := dynamicQuery.Args
	if len(argsLen) == 1 {
		argName = dynamicQuery.Args[0]
	}

	if err := g.applyTemplate(tpl, SqlFunc{
		BrickName:    brickName,
		FuncName:     definition.Name,
		Segments:     dynamicQuery.Segments,
		Conditions:   dynamicQuery.Conditions,
		IndexOfWhere: dynamicQuery.IndexOfWhere,
		RemoveComma:  dynamicQuery.RemoveLastComma,
		Mapper:       definition.Mapper,
		IsTx:         definition.IsTx,
		Args:         dynamicQuery.Args,
		ArgName:      argName,
		TotalArgs:    len(dynamicQuery.Args),
		Comment:      statement.Comment,
	}); err != nil {
		log.Printf("error: %v", err)
	}
	g.NewLine()
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format(outputFilename string) []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}

	importedSrc, err := imports.Process(outputFilename, src, nil)
	if err != nil {
		log.Printf("warning: internal error: invalid Go generated: %s", err)
	}

	return importedSrc
}

// Output will create a source code file and write all code.
func (g *Generator) Output(filename string) error {
	if err := os.MkdirAll(g.outputDir, os.ModePerm); err != nil {
		return err
	}
	outputFilename := filepath.Join(g.outputDir, strings.ToLower(filename))
	return ioutil.WriteFile(outputFilename, g.format(outputFilename), 0644)
}
